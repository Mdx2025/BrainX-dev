#!/bin/bash
# BrainX CLI v1.0 - Unified command interface
# Usage: brainx <command> [args]

set -euo pipefail

# Base paths
BRAINX_BASE="${OPENCLAW_WORKSPACE:-$HOME/.openclaw/workspace}/.brainx"
BRAINX_SCRIPTS="$BRAINX_BASE/scripts"
BRAINX_CLI="$BRAINX_BASE/cli"
BRAINX_CONFIG="$BRAINX_BASE/config"

# Load config
source "$BRAINX_CONFIG/core.conf" 2>/dev/null || true

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m'

# Helpers
log_info() { echo -e "${BLUE}[ℹ]${NC} $1"; }
log_success() { echo -e "${GREEN}[✓]${NC} $1"; }
log_warn() { echo -e "${YELLOW}[⚠]${NC} $1"; }
log_error() { echo -e "${RED}[✗]${NC} $1"; }

# Show help
show_help() {
    cat << 'EOF'
╔══════════════════════════════════════════════════════════╗
║              BrainX v1.0 - Unified CLI                   ║
╚══════════════════════════════════════════════════════════╝

Usage: brainx <command> [args]

Commands:
  add <type> <content> [--category=X] [--tags=a,b]
                    Add a new entry to BrainX

  search <query> [--limit=N] [--tier=hot|warm|cold]
                    Search entries by content

  recall [context] [--limit=N] [--days=N]
                    Recall relevant entries based on context

  inject <query>    Show entries matching query (for LLM injection)

  learn <file> [--auto-classify]
                    Learn from transcript or file

  migrate [--dry-run|--rollback]
                    Migrate from legacy systems

  health            Check BrainX system health

  stats             Show BrainX statistics

  export [--format=jsonl|json]
                    Export BrainX data

  help              Show this help message

Examples:
  brainx add decision "Usar PostgreSQL para el proyecto"
  brainx search "postgres" --limit=5
  brainx recall "database migration" --limit=10
  brainx inject "qué database usar"
  brainx learn transcript.txt
  brainx migrate --dry-run
  brainx health
  brainx stats

EOF
}

# Initialize BrainX
init_brainx() {
    "$BRAINX_SCRIPTS/core-engine.sh" init 2>/dev/null || true
}

# Add entry
brainx_add() {
    local type="${1:-note}"
    shift || true
    local content="$*"
    local category="general"
    local tags="[]"
    local tier="warm"
    
    # Parse options
    while [[ "$content" == --* ]]; do
        case "$content" in
            --category=*) category="${content#*=}"; shift; content="$*" ;;
            --tags=*) 
                local tag_str="${content#*=}"
                tags="[\"$(echo "$tag_str" | sed 's/,/","/g')\"]"
                shift; content="$*"
                ;;
            --tier=*) tier="${content#*=}"; shift; content="$*" ;;
            *) shift; content="$*" ;;
        esac
    done
    
    if [ -z "$content" ]; then
        log_error "Content required"
        return 1
    fi
    
    # Build JSON entry
    local timestamp=$(date -Iseconds)
    local id="bx_$(date +%s)_$(echo "$content" | sha256sum | cut -c1-8)"
    
    local entry=$(jq -n \
        --arg id "$id" \
        --arg timestamp "$timestamp" \
        --arg content "$content" \
        --arg type "$type" \
        --arg tier "$tier" \
        --arg category "$category" \
        --argjson tags "$tags" \
        '{
            id: $id,
            timestamp: $timestamp,
            source: "cli:add",
            content: {raw: $content, processed: $content, summary: ""},
            classification: {type: $type, tier: $tier, category: $category, confidence: 0.95},
            entities: [],
            relations: [],
            context: {session_id: "cli", agent: "brainx", channel: "cli"},
            metadata: {extracted_from: "cli", auto_learned: false, verified: true},
            tags: $tags,
            access_count: 0,
            last_accessed: $timestamp
        }')
    
    echo "$entry" >> "$BRAINX_DB"
    log_success "Added entry: $id"
    echo "  Type: $type | Tier: $tier | Category: $category"
}

# Search entries
brainx_search() {
    local query="$1"
    shift || true
    local limit=10
    local tier=""
    
    while [[ $# -gt 0 ]]; do
        case $1 in
            --limit=*) limit="${1#*=}" ;;
            --tier=*) tier="${1#*=}" ;;
        esac
        shift
    done
    
    if [ ! -f "$BRAINX_DB" ]; then
        log_warn "No BrainX database found"
        return 1
    fi
    
    log_info "Searching for: '$query'"
    
    local results=$(jq -r --arg q "$query" --arg tier "$tier" '
        select(.content.raw | ascii_downcase | contains($q | ascii_downcase))
        | select(if $tier != "" then .classification.tier == $tier else true end)
        | "\(.timestamp) | [\(.classification.type)] \(.content.raw[:80])..."
    ' "$BRAINX_DB" 2>/dev/null | head -n "$limit")
    
    if [ -z "$results" ]; then
        log_warn "No results found"
    else
        echo "$results"
        echo ""
        local count=$(echo "$results" | wc -l)
        log_info "Found $count results"
    fi
}

# Recall entries
brainx_recall() {
    local context="${1:-}"
    local limit=5
    local days=30
    
    shift || true
    while [[ $# -gt 0 ]]; do
        case $1 in
            --limit=*) limit="${1#*=}" ;;
            --days=*) days="${1#*=}" ;;
        esac
        shift
    done
    
    if [ ! -f "$BRAINX_DB" ]; then
        log_warn "No BrainX database found"
        return 1
    fi
    
    local cutoff=$(date -d "$days days ago" -Iseconds 2>/dev/null || date -v-${days}d -Iseconds)
    
    log_info "Recalling relevant entries..."
    
    # Simple relevance: hot tier first, then by access count
    local results=$(jq -r --arg ctx "$context" --arg cutoff "$cutoff" '
        select(.timestamp >= $cutoff)
        | . as $entry
        | {
            tier_score: (if .classification.tier == "hot" then 3 elif .classification.tier == "warm" then 2 else 1 end),
            access_score: (.access_count // 0),
            entry: .
        }
        | .entry
    ' "$BRAINX_DB" 2>/dev/null | head -n "$limit")
    
    if [ -z "$results" ]; then
        # Fallback: show recent entries
        results=$(tail -n "$limit" "$BRAINX_DB" 2>/dev/null | jq -r '"\(.timestamp) | [\(.classification.tier)] \(.content.raw[:60])..."')
    fi
    
    echo "$results"
}

# Inject (for LLM context)
brainx_inject() {
    local query="$1"
    
    if [ ! -f "$BRAINX_DB" ]; then
        return 1
    fi
    
    # Return formatted context for injection
    local context=$(jq -r --arg q "$query" '
        select(.classification.tier == "hot" or .classification.tier == "warm")
        | select(.content.raw | ascii_downcase | contains($q | ascii_downcase))
        | "[\(.classification.type | ascii_upcase)] \(.content.raw)"
    ' "$BRAINX_DB" 2>/dev/null | head -n 5)
    
    if [ -n "$context" ]; then
        echo "=== BrainX Context ==="
        echo "$context"
        echo "======================"
    fi
}

# Learn from file
brainx_learn() {
    local file="$1"
    
    if [ ! -f "$BRAINX_SCRIPTS/learn.sh" ]; then
        log_error "Learn script not found"
        return 1
    fi
    
    "$BRAINX_SCRIPTS/learn.sh" "$file"
}

# Migrate data
brainx_migrate() {
    if [ ! -f "$BRAINX_SCRIPTS/migrate.sh" ]; then
        log_error "Migrate script not found"
        return 1
    fi
    
    # If no args or first arg starts with --, use 'all' as source
    if [ $# -eq 0 ] || [[ "${1:-}" == --* ]]; then
        "$BRAINX_SCRIPTS/migrate.sh" all "$@"
    else
        "$BRAINX_SCRIPTS/migrate.sh" "$@"
    fi
}

# Health check
brainx_health() {
    log_info "Checking BrainX system health..."
    echo ""
    
    local issues=0
    BRAINX_BACKUP="${BRAINX_BACKUPS:-$BRAINX_BASE/backups}"
    
    # Check directories
    for dir in "$BRAINX_BASE" "$BRAINX_CONFIG" "$BRAINX_SCRIPTS" "$BRAINX_STORAGE" "$BRAINX_BACKUP"; do
        if [ -d "$dir" ]; then
            echo -e "  ${GREEN}✓${NC} Directory: $(basename "$dir")"
        else
            echo -e "  ${RED}✗${NC} Directory missing: $(basename "$dir")"
            issues=$((issues + 1))
        fi
    done
    
    # Check files
    if [ -f "$BRAINX_DB" ]; then
        local entries=$(wc -l < "$BRAINX_DB" | tr -d ' ')
        echo -e "  ${GREEN}✓${NC} Database: $entries entries"
    else
        echo -e "  ${YELLOW}⚠${NC} Database: empty (will be created on first use)"
    fi
    
    if [ -f "$BRAINX_CONFIG/core.conf" ]; then
        echo -e "  ${GREEN}✓${NC} Config: core.conf"
    else
        echo -e "  ${RED}✗${NC} Config: missing"
        issues=$((issues + 1))
    fi
    
    # Check scripts
    for script in core-engine.sh backup-engine.sh migrate.sh learn.sh; do
        if [ -f "$BRAINX_SCRIPTS/$script" ]; then
            echo -e "  ${GREEN}✓${NC} Script: $script"
        else
            echo -e "  ${YELLOW}⚠${NC} Script: $script (optional)"
        fi
    done
    
    echo ""
    if [ $issues -eq 0 ]; then
        log_success "BrainX is healthy ✓"
        return 0
    else
        log_warn "BrainX has $issues issue(s) - run 'brainx init' to fix"
        return 1
    fi
}

# Show stats
brainx_stats() {
    log_info "BrainX Statistics"
    echo ""
    
    if [ ! -f "$BRAINX_DB" ]; then
        log_warn "No database found"
        return 1
    fi
    
    local total=$(wc -l < "$BRAINX_DB" | tr -d ' ')
    local hot=$(jq 'select(.classification.tier == "hot")' "$BRAINX_DB" 2>/dev/null | wc -l | tr -d ' ')
    local warm=$(jq 'select(.classification.tier == "warm")' "$BRAINX_DB" 2>/dev/null | wc -l | tr -d ' ')
    local cold=$(jq 'select(.classification.tier == "cold")' "$BRAINX_DB" 2>/dev/null | wc -l | tr -d ' ')
    local decisions=$(jq 'select(.classification.type == "decision")' "$BRAINX_DB" 2>/dev/null | wc -l | tr -d ' ')
    local actions=$(jq 'select(.classification.type == "action")' "$BRAINX_DB" 2>/dev/null | wc -l | tr -d ' ')
    local auto_learned=$(jq 'select(.metadata.auto_learned == true)' "$BRAINX_DB" 2>/dev/null | wc -l | tr -d ' ')
    
    echo "  Total entries:    $total"
    echo "  Hot tier:         $hot"
    echo "  Warm tier:        $warm"
    echo "  Cold tier:        $cold"
    echo ""
    echo "  Decisions:        $decisions"
    echo "  Actions:          $actions"
    echo "  Auto-learned:     $auto_learned"
}

# Export data
brainx_export() {
    local format="jsonl"
    
    while [[ $# -gt 0 ]]; do
        case $1 in
            --format=*) format="${1#*=}" ;;
        esac
        shift
    done
    
    if [ ! -f "$BRAINX_DB" ]; then
        log_error "No database to export"
        return 1
    fi
    
    BRAINX_BACKUP="${BRAINX_BACKUPS:-$BRAINX_BASE/backups}"
    local output="$BRAINX_BACKUP/brainx_export_$(date +%Y%m%d_%H%M%S)"
    
    if [ "$format" = "json" ]; then
        output="${output}.json"
        jq -s '.' "$BRAINX_DB" > "$output"
    else
        output="${output}.jsonl"
        cp "$BRAINX_DB" "$output"
    fi
    
    log_success "Exported to: $output"
}

# Main
case "${1:-help}" in
    add)
        shift
        brainx_add "$@"
        ;;
    search)
        shift
        brainx_search "$@"
        ;;
    recall)
        shift
        brainx_recall "$@"
        ;;
    inject)
        shift
        brainx_inject "$@"
        ;;
    learn)
        shift
        brainx_learn "$@"
        ;;
    migrate)
        shift
        brainx_migrate "$@"
        ;;
    health)
        brainx_health
        ;;
    stats)
        brainx_stats
        ;;
    export)
        shift
        brainx_export "$@"
        ;;
    help|--help|-h)
        show_help
        ;;
    *)
        log_error "Unknown command: $1"
        show_help
        exit 1
        ;;
esac
